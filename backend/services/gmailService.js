import { google } from 'googleapis';
import { query } from '../db/connection.js';
import logger from '../utils/logger.js';

/**
 * Get OAuth2 client for Gmail API
 */
export function getOAuth2Client() {
    return new google.auth.OAuth2(
        process.env.GOOGLE_CLIENT_ID,
        process.env.GOOGLE_CLIENT_SECRET,
        process.env.GOOGLE_REDIRECT_URI
    );
}

/**
 * Get authenticated OAuth2 client for a user's email account
 */
export async function getAuthenticatedClient(userId) {
    const result = await query(
        'SELECT * FROM email_accounts WHERE user_id = $1 AND is_connected = true LIMIT 1',
        [userId]
    );

    if (result.rows.length === 0) {
        throw new Error('No email account connected');
    }

    const account = result.rows[0];
    const oauth2Client = getOAuth2Client();

    oauth2Client.setCredentials({
        access_token: account.access_token,
        refresh_token: account.refresh_token,
        expiry_date: new Date(account.token_expires_at).getTime()
    });

    // Auto-refresh token if expired
    oauth2Client.on('tokens', async (tokens) => {
        if (tokens.refresh_token) {
            await query(
                'UPDATE email_accounts SET access_token = $1, refresh_token = $2, token_expires_at = $3 WHERE id = $4',
                [tokens.access_token, tokens.refresh_token, new Date(tokens.expiry_date), account.id]
            );
        } else {
            await query(
                'UPDATE email_accounts SET access_token = $1, token_expires_at = $2 WHERE id = $3',
                [tokens.access_token, new Date(tokens.expiry_date), account.id]
            );
        }
    });

    return { oauth2Client, account };
}

/**
 * Parse Gmail message to our format
 */
export function parseGmailMessage(gmailMessage) {
    const headers = gmailMessage.payload.headers;
    const getHeader = (name) => headers.find(h => h.name.toLowerCase() === name.toLowerCase())?.value || '';

    let body = '';
    if (gmailMessage.payload.body.data) {
        body = Buffer.from(gmailMessage.payload.body.data, 'base64').toString('utf-8');
    } else if (gmailMessage.payload.parts) {
        const textPart = gmailMessage.payload.parts.find(part => part.mimeType === 'text/plain');
        if (textPart && textPart.body.data) {
            body = Buffer.from(textPart.body.data, 'base64').toString('utf-8');
        }
    }

    return {
        message_id: gmailMessage.id,
        thread_id: gmailMessage.threadId,
        from_email: getHeader('from'),
        from_name: getHeader('from').split('<')[0].trim(),
        subject: getHeader('subject'),
        body: body,
        snippet: gmailMessage.snippet,
        received_at: new Date(parseInt(gmailMessage.internalDate)),
        is_read: !gmailMessage.labelIds?.includes('UNREAD')
    };
}

/**
 * Create email reply in RFC 2822 format
 */
export function createEmailReply(originalEmail, replyText, fromEmail) {
    const subject = originalEmail.subject.startsWith('Re:')
        ? originalEmail.subject
        : `Re: ${originalEmail.subject}`;

    const email = [
        `From: ${fromEmail}`,
        `To: ${originalEmail.from_email}`,
        `Subject: ${subject}`,
        `In-Reply-To: ${originalEmail.message_id}`,
        `References: ${originalEmail.message_id}`,
        '',
        replyText
    ].join('\r\n');

    return Buffer.from(email).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

/**
 * Check if email should be filtered out
 */
export function shouldFilterEmail(email, filters) {
    // Skip promotional emails
    if (filters.skipPromotions && email.snippet.toLowerCase().includes('unsubscribe')) {
        return true;
    }

    // Skip auto-generated emails
    if (filters.skipAutoGenerated) {
        const autoGeneratedIndicators = ['noreply', 'no-reply', 'donotreply', 'automated'];
        if (autoGeneratedIndicators.some(indicator => email.from_email.toLowerCase().includes(indicator))) {
            return true;
        }
    }

    // Check blacklist
    if (filters.blacklist && Array.isArray(filters.blacklist)) {
        if (filters.blacklist.some(blocked => email.from_email.toLowerCase().includes(blocked.toLowerCase()))) {
            return true;
        }
    }

    return false;
}
